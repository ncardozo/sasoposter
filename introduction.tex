% $ Id: introduction.tex  $
% !TEX root = main.tex

%%
\section{Introduction}
\label{sec:introduction}

The current practice of software development is strongly supported by \acp{VCS} like 
subversion\footnote{\url{http://subversion.apache.org/}} and Git,\footnote{\url{http://git-scm.com}} as 
they enable software developers to reduce the risk of losing progress of their activities, and offer the 
possibility of maintaining different variants of the code-base to serve different costumers.
The main characteristics of using \acp{VCS} in software development processes are:
\begin{enumerate*}[label=(\arabic*)]
\item traceability over each file's change history, 
\item concurrent editing, and 
\item branching and merging of code extracts on independent streams of changes. 
\end{enumerate*}
These characteristics, enable to manage progress, backups, and variations of a software system as 
part of the development and maintenance activities of a software project~\cite{spinellis05}.

Taking advantage of \acp{VCS},  it is possible for software developers to embrace a \ac{DSD} model, in 
which development teams are distributed in both, location and time. This model is beneficial in reducing 
costs, and finding human talent in different locations; which are aimed to increase the productivity of a 
development team. 
Similar to the \ac{DSD} model, a \ac{SPL} model can be supported by \acp{VCS}. Different variants of a 
product can be maintained independently, as part of a single development project, to provide 
personalized alternatives to different customers. This reduces development costs, due to resource 
reutilization, and a faster go to market cycle~\cite{pohl05}.  

%why
\acp{VCS} offer mechanisms like commit, push, and merge to manage versions and variants in a 
software project. With these mechanisms it is possible to solve synchronization and coordination 
problems as they arise. 
Notwithstanding, these mechanisms introduce an overhead for the development workflow. Users must interrupt their development tasks to interact with the \ac{VCS}. For example, $70\%$ of developers spend between $5$ and  $20$ minutes solving synchronization and merging issues, significantly harming developer's productivity~\cite{estler14}. Additionally, in some cases, developers are unaware of the work produced by other team members, having a negative impact on productivity when working with existing code (\eg in maintenance tasks)~\cite{dourish92}.

Using \acp{VCS} for variant management also presents overhead in the productivity of software development teams, as the initial configuration is created~\cite{niu14}.
Moreover, frequent interaction with the \ac{VCS} increases the development time due to the context switch in the developer's mindset, taking longer to focus back on the development activity. Sporadic interaction with the \ac{VCS} can lead to synchronization issues, and in turn, to longer development cycles~\cite{schwagerl15}.  

%what
To address the aforementioned problems when using \acp{VCS} to track program versions or manage \acp{SPL}, we propose an integrated development environment, CollabIDE, focused on the distributed  collaboration in software product development (\fref{sec:collab-ide}). CollabIDE integrates an automated \ac{VCS}, and a lightweight \ac{SPL} model for the generation of multiple variants from a single code base. 
%How
CollabIDE is built on top of the dynamic behavior adaptation model proposed by \ac{COP}~\cite{salvaneschi+12survey}. To use this model, we define versions as context objects (based on available information \eg the logged in user).
Product variants are managed based on the defined versions, where a variant is generated using a subset of all defined versions.

To validate CollabIDE, we conducted a small empirical study with users working in distributed teams 
(\fref{sec:validation}). Each team had to develop different programming tasks following a sequence of 
commands to share code with their development team, and release different product variants. For each 
team we gathered information about the time spent performing actions related to version control and the 
percentage of tasks they could complete in the time limit. This information shows an improvement in 
productivity of about $11\%$, and a general acceptance towards the tool (gathered from a survey after 
the experiment).

We present this paper as follows. In \fref{sec:collab-ide} we describe CollabIDE and how its core features allow us to approach the problem at hand. In addition to this
we explain the most important aspects of its implementation. \fref{sec:validation} details our empirical study setup, execution and results.
In \fref{sec:related} we show other tools that a have a similar approach to that of CollabIDE. Finally in \fref{sec:conclusion} we conclude the paper and talk about future work.
 

\endinput

With CollabIDE, we aim to solve the overhead problems that exists in these development models with 
features that aim to reduce the time developers must spend doing actions related to version control or 
setting up a project that uses \acp{SPL}.
